<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机网络——传输层]]></title>
    <url>%2F2018%2F06%2F29%2Ftransport-layer%2F</url>
    <content type="text"><![CDATA[传输层概述在 OSI（Open System Interconnection, 开发系统互联）七层模型中，传输层是面向通信的最高层，也是面向用户功能的最底层。 传输层有两大功能： 复用：在发送端，多个应用进程共有一个传输层。 分用：在接收端，传输层根据端口号将数据分派给不同的应用进程。 传输层和网络层的区别： 网络层是为不同主机提供通信服务，而传输层是为不同主机的不同应用程序提供通信服务。 网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。 UDP 协议UDP 的特点UDP（User Datagram Protocol, 用户数据报协议）有以下特点： 无连接通信前不需要建立连接，通信结束也无须释放连接。 不可靠UDP 是尽力而为交付，不能确保每个数据报都送达。 面向报文UDP 数据传输的基本单位是报文，它不会对数据做任何拆分或拼接操作。在发送端，应用程序给传输层的 UDP 什么数据，UDP 不会对数据进行拆分，只增加一个 UDP 头后就交给网络层；在接收端，UDP 收到网络层的数据报后，不会作任何拼接操作，去掉数据报头后便交给应用层。 没有拥塞控制UDP 始终以恒定的速率发送数据，它不会根据网络拥塞情况对发送速率作出调整。这种方式可能导致数据丢失，但可以应用在“直播、语音通话”这种允许数据丢失、但对实时性要求较高的场景。 支持一对一、一对多、多对一、多对多通信 首部开销小，只有 8 字节 UDP 头部UDP 头部只有 8 字节，包括： 16 位源端口 16 位目的端口 16 位 UDP 长度 16 位 UDP 检验和 TCP 协议TCP 的特点TCP（Transmission Control Protocol, 传输控制协议）有以下特点： 面向连接通信前需要建立连接，通信结束后需要释放连接。 可靠TCP 发送的数据无重复、无丢失、与发送端顺序一致。 面向字节流TCP 以字节位单位，传输的过程中数据被划分成一个个数据报。 全双工通信TCP 的两端既可以作为发送端，也可以作为接收端。 一条 TCP 连接的两端只能有两个端点TCP 只能提供点到点的通信，而 UDP 可以任意方式的通信。一条 TCP 连接的两端就是两个套接字，套接字 = IP: 端口号。 TCP 头部TCP 头部通常有 20 字节，有选项时更长，但总共不超过 60 字节。包括： 源端口、目的端口（共 4 字节）传输层和网络层的一大重要区别就是：传输层指定了数据报发往的应用进程，因此需要端口号标识。 序号（4 字节）当前 TCP 数据报数据部分的第一个字节的序号。TCP 是面向字节流的，它会对发送的每一个字节进行编号，而且不同数据报之间是连续编号的。 确认号（4 字节）表示当前主机作为接收端，期望接收的下一个字节的编号。 数据偏移（4 字节）数据部分距离报文段起始部分的偏移，其实就是头部的长度。 保留字段 标识符 URG：该字段被置 1 时，表示当前数据报的数据部分包含紧急信息，紧急数据一定是在数据部分的最前面，紧急指针标明了紧急数据的尾部。 ACK：该字段被置 1 时，确认号字段才有效。在连接建立后传送的所有报文短都必须把 ACK 置 1。 PSH：当接收方收到 PSH=1 的报文后，会立即将数据交给应用程序，而不是等到缓冲区满了后才提交。 RST：该值为 1 时，表示当前 TCP 连接出现严重问题，需要释放重连。 SYN：SYN 在建立连接的时候使用。（SYN=1, ACK=0）表示当前报文段是一个连接请求报文；（SYN=1, ACK=1）表示当前报文是一个同意建立连接的应答报文。 FIN：FIN=1 表示此报文段是一个释放连接的请求报文。 接收窗口大小表示当前接收窗口的剩余容量大小，用于实现 TCP 的流量控制。发送方收到该值后会将发送窗口调整为该值的大小。发送窗口的大小又影响了发送速率，所以接收方通过设置该值控制发送方的发送速率。 检验和用于接收端检验整个数据报在传输过程中是否出错。 紧急指针用于标识紧急数据的尾部。 选项字段长度可选。 TCP 三次握手假设 A 为客户端，B 为服务端。 首先 B 处于LISTEN状态，等待 A 的连接请求。 A 向 B 发送请求报文， （SYN=1, ACK=0），发送后 A 进入SYN-SENT状态。 B 收到 A 的请求报文，如果同意建立连接，则向 A 发送连接确认报文段，（SYN=1, ACK=1），发送后 B 进入SYN-RCVD状态。 A 收到 B 的连接确认报文段，还要向 B 发送一个确认报文段，发送后 A 进入ESTABLISHED状态，B 收到后也进入ESTABLISHED状态，从而连接建立。 为什么是三次握手？而不是两次？其实是防止失效的连接被服务端接收，导致服务端错误打开连接而浪费资源。如果建立连接只需要两次握手，客户端没有太大变化，它在获得服务端的应答后进入ESTABLISHED状态，而服务端会在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的请求迟迟到不了服务端，客户端会超时重发，如果服务端正确接收并确认应答，双方开始通信，通信接收后释放连接。此时如果那个失效的连接请求抵达服务端，由于只有两次握手，服务端会进入ESTABLISHED状态，而此时客户端早已进入CLOSED状态，服务端会一直等待下去，从而浪费服务端连接资源。 TCP 四次挥手TCP 连接的释放一共需要四步，称为“四次挥手”。前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一个方向的连接。 A 发送连接释放报文段， FIN=1，之后进入FIN-WAIT-1状态。 B 收到后，向 A 发送连接应答，进入CLOSE-WAIT状态。 A 收到该应答，进入FIN-WAIT-2状态，等待 B 发送连接释放的请求。 当 B 不再需要连接时，向 A 发送连接释放的请求报文， FIN=1，之后 B 进入LAST-ACK状态。 A 收到释放请求后，向 B 发送应答，进入TIME-WAIT状态，等待 2MSL 后进入CLOSED状态，B 收到应答后，也进入CLOSED状态。 为什么 A 要先进入TIME-WAIT状态，等待 2MSL 时间后再进入CLOSED状态？其实是为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接CLOSED，如果该应答丢失，B 等待超时，会重新发送释放连接的请求，此时 A 已经关闭了，不会作出任何响应，B 永远无法正常关闭。 TCP 可靠传输的表现TCP 的可靠性在于，它向应用层提供的数据是无差错、有序、无丢失的。TCP 采用流量控制、拥塞控制、连续 ARQ 等技术保证它的可靠性。 停止等待协议（ARQ 协议）TCP 保证其可靠性采用的是更为复杂的滑动窗口协议，但停止等待协议是它的简化版，因此这里先介绍停止等待协议。ARQ（Automatic Repeat reQuest, 自动重传请求），就是当请求失败时它会自动重传，直到请求被正确接收为止。 无差错的情况A 向 B 每发送一个分组，都要停止发送，收到 B 的确认应答后才发送下一个分组。 分组丢失、出现差错的情况分组丢失：分组在途中丢失，B 收不到，因此不会有响应，A 超时后会重传。出现差错：B 收到分组，但检查到分组有差错，会直接丢弃，不会有响应，A 同样超时重传。 应答丢失、应答迟到的情况应答丢失：B 收到分组，返回应答，但应答在途中丢失了，A 超时重传，紧接着 B 又收到该分组，判断该是否已接收，若已接收则直接丢弃，并补上一个应答。应答迟到：B 收到分组，返回应答，但由于网路拥塞，A 没有及时收到分组，导致超时重传，之后前面的应答抵达 A，A 判断是否已接收，若是则直接丢弃即可。 滑动窗口协议（连续 ARQ 协议）在 ARQ 协议中，发送者每次只能发送一个分组，在应答到来前必须等待，而连续 ARQ 协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样减少了等待时间，提高了传输的效率。 窗口是缓存的一部分，用来暂时存放字节流。发送者和接收者各有一个窗口，接收者通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送者根据这个值和其它信息设置自己的窗口大小。 如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。 TCP 协议的两端分别为发送者 A 和接收者 B，由于是全双工通信，因此 A 和 B 应该分别维护着一个独立的发送缓冲区和接收缓冲区。 TCP 流量控制流量控制是为了避免分组丢失，通过控制发送方发送速率，保证接收方来得及接收。它通过滑动窗口协议实现。 流量控制可能引发死锁。当发送者收到一个窗口为 0 的应答时，进入等待状态，等待接收者的下一个应答。如果下一个窗口不为 0 的应答在途中丢失，会导致发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待下去，从而产生死锁。为了避免死锁，TCP 使用了持续计时器，每当发送者收到一个 0 窗口的应答后就启动计数器，时间一到会询问接收者窗口的大小。若依然为 0，则重新启动计时器，如此下去…… TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送者会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送者的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收者能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。 快重传与快恢复对于接收者，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。而对于发送方，如果收到三个重复确认，那么可以确定下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>UDP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费搭建属于自己的博客]]></title>
    <url>%2F2018%2F06%2F29%2Fbuild-your-own-blog%2F</url>
    <content type="text"><![CDATA[对于一个没有一点编程基础的同学来说，搭建这样的一个博客，难吗？ 不难，说真的。但不是说很简单，它需要你去了解一些小知识点，比如 Git 命令行的使用、GitHub 仓库的创建、代码的远程部署等等……它不像我们安装某些软件一样，只要把安装包下载下来，运行安装程序，一路 next 到最后完成即可。 这篇文章里，我会大致说一下搭建的流程以及用到的每个工具的作用，但不会详细讲一步步具体该怎么操作，因为网上有太多详细的教程了，只要你会用搜索引擎。 安装 GitGit 是一个版本控制软件，或者说是一个管理代码的工具，特别适合用于团队的协作开发中。在公司，一般是团队协作完成软件/系统的开发，同事把代码提交到远程仓库，你可以在自己电脑上通过 Git 命令将代码克隆下来，创建分支，加进去你的代码，提交的时候可以 merge 合并分支，协作完成开发工作。 我们搭建自己的博客，需要将代码部署到 GitHub 上，用的就是 Git 的一些基本命令，比如 commit、push… 安装 Node.js我的这个博客用的是 Hexo 框架，它基于 Node.js 开发，因此，在安装 Hexo 之前，首先需要安装 Node.js。而 npm 是 Node.js 的一个包管理工具，安装完 Node.js 之后，就有了 npm。通过 npm 我们可以把搭建博客需要的一些代码包（如 Hexo）下载下来并完成安装。 安装 Hexo通过执行 npm 命令安装即可。 初始化博客安装完 Hexo，在自己喜欢的文件夹下初始化 Hexo 博客，并配置一些相关信息，比如博客网站的标题、语言(zh-Hans)等等。 安装主题这一步可以不做，你完全可以用 Hexo 的默认主题，只是我嫌弃它默认的主题样式不好看，因此安装了 nexT 主题样式，看起来舒服多了，这个过程可以做一些个性化配置，比如文章的展示方式……只要在主题文件夹下修改 _config.yml 文件的配置信息即可。 在 GitHub 上创建仓库以上我们是在自己电脑上操作的，外部无法访问到我们的博客，因此，可以将页面代码部署到 GitHub 仓库上，由 GitHub 帮我们解析页面供外部访问。部署的时候，需要有密钥，一般是用 SSH，保证只有自己能上传代码到自己的仓库上。部署完成之后，基本上就搞定了。 添加 GitmentGitment 是一款基于 GitHub Issues 的评论系统，可以为我们的博客添加评论功能，完全不需要后台服务器，用户的每一条评论会存储到 GitHub 的 Issues 上，你可以像我一样，将评论添加在自己的博客仓库中，也可以新创建一个仓库专门用于存储评论。 评论时需要用户登录 GitHub 账号，没有 GitHub 账号的用户是评论不了的，这与 Gitment 基于 GitHub Issues 有关。 似乎就这么多了，详细的搭建过程以及如何开始文章的创作，查看网上教程就好了，我就不把链接贴出来了~]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见，德国]]></title>
    <url>%2F2018%2F06%2F28%2FGoodbye-Germany%2F</url>
    <content type="text"><![CDATA[生活无比残酷，幸运女神不会永远眷顾着你，还是要坚强面对生活。 再见，日耳曼战车。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Just Do IT]]></title>
    <url>%2F2018%2F06%2F27%2FJust-Do-IT%2F</url>
    <content type="text"><![CDATA[复习计划 JVM Java Web Spring MyBatis 设计模式 操作系统 数据库 计算机网络 数据结构与算法 Java 基础 Java 并发 Java 容器 Java IO]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
</search>
