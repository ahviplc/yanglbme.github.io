<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>一学期又结束了</title>
      <link href="/2018/07/07/finish-final-exam/"/>
      <url>/2018/07/07/finish-final-exam/</url>
      <content type="html"><![CDATA[<p>昨天下午考完了最后一科《编程语言》，我的大学课程算是完全修完了（应该不至于挂科）…<br><img src="http://p9ucdlghd.bkt.clouddn.com/final-exam.png" alt="final-exam"></p><a id="more"></a><p>从 2016 年开始，因为修读了软件工程第二学位，我比身边不少小伙伴少了很多空闲时间，平时忙于做实验写报告，跟他们一起出去玩耍的机会也少了。</p><p>我不后悔修读软件工程双学位。我已经决定毕业之后从事<code>Programming</code>的职业，既是兴趣爱好，也是性格所向。我个人比较内敛😳，不是很擅长与别人打交道，相信跟我相处过的人都知道，但我会与别人相处得很好，不会闹什么小矛盾。前段时间有朋友来找我说要不要一起租房，他毕业了，想找一个比较靠谱的朋友一起合租，我听了是很感动(ಥ _ ಥ)的，但因为双学位的原因，我还有一年时间才毕业，所以暂时没机会一起租房了。另外，我喜欢编程，相比于各种杂七杂八的活动、四处跑业务，我更喜欢安安静静坐在电脑💻前<code>Coding</code>，虽然有时因为调<code>bug</code>而四处碰壁，但在<code>fixed bugs</code>后，我会开心得像个小屁孩😀活蹦乱跳~</p><p>在去年 7 月份我决定做<code>Java</code>开发，但那时，我对 Java 是一无所知，我至今不知道自己当时哪来的冲动突然选了 Java 方向。一直坚持到今天，自学了一年 Java 的我，觉得自己在 Java 方面进步还是挺大的~</p><p>接下来还有很多事情要做，实习、秋招、两份毕业设计，💪加油干吧~</p>]]></content>
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> talk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统知识总结3</title>
      <link href="/2018/07/04/all-os3/"/>
      <url>/2018/07/04/all-os3/</url>
      <content type="html"><![CDATA[<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><ul><li>CPU 寄存器</li><li>Cache 高速缓存</li><li>主存储器（内存/主存）</li><li>磁盘缓存</li><li>固定磁盘</li><li>可移动存储介质</li></ul><a id="more"></a><p>在存储层次中，层次越高（越靠近 CPU），存储介质的访问速度越快，价格也就越高，相应所配置的存储容量也越小。<br>高速缓存、主存储器和磁盘缓存均属于操作系统<strong>存储管理的管辖范畴</strong>，掉电后存储的信息就不存在了。而低层的固定磁盘和可移动存储介质则属于<strong>设备管理的管辖范畴</strong>，它们存储的信息将被长期保存。</p><h3 id="存储器的管理目标"><a href="#存储器的管理目标" class="headerlink" title="存储器的管理目标"></a>存储器的管理目标</h3><ul><li>为用户使用存储器提供方便，用户只需要在自己的逻辑内存空间编程，不需要考虑真实内存的物理位置。</li><li>为用户提供充分大的存储空间。</li><li>提高内存的利用率，将尽量多的用户调入内存运行。</li></ul><h3 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h3><p>程序进入内存的流程步骤：</p><ul><li>编译：源代码 -&gt; 目标模块</li><li>链接：目标模块 + 库函数 -&gt; 装入模块</li><li>装入：装入内存</li></ul><p><img src="http://p9ucdlghd.bkt.clouddn.com/compile-link-load.png" alt="compile-link-load"></p><h3 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h3><p>为了能将用户程序装入内存，必须为它分配一定大小的内存空间。连续分配方式是最早出现的一种存储器分配方式，该方式是为一个用户程序分配一个连续的内存空间。有以下几种分配方式：</p><ul><li>单一连续分配<br>在单道程序环境下，内存分为<strong>系统区</strong>和<strong>用户区</strong>两部分。整个内存的用户空间由该程序独占。</li><li>固定分区连续分配（容易造成浪费）<br>将内存划分为多个区域，每个区域大小固定且只能装入一个程序。<br>分区大小相等的划分一般用于多个相同任务；分区大小不等的划分一般根据实际任务大小分配。<br><img src="http://p9ucdlghd.bkt.clouddn.com/fixed-size-partition.png" alt="fixed-size-partition"></li><li>动态分区分配<br>无固定分区，在整块内存空间中动态分割；根据程序大小，动态分配<strong>连续</strong>的内存空间，分配的内存大小等于程序大小。</li><li>基于顺序搜索的动态分区分配算法<br>为了<strong>实现动态分区分配</strong>，通常是将系统中的空闲分区链接成一个链。顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。有以下几种算法：<ul><li><strong>首次适应算法</strong><br>首次适应（First Fit, FF）算法是按顺序选择第一个满足要求的内存区域。<br><strong>优点</strong>：保留了高地址的大部分空间，为以后到达的大作业分配大的内存空间创造了条件。<br><strong>缺点</strong>：低址部分不断被划分，会留下许多难以利用的、很小的空间（碎片）。</li><li><strong>循环首次适应算法</strong><br>循环首次适应（Next Fit, NF）算法是在上一次找到空闲分区的下一个分区开始寻找，找到第一个满足要求的内存区。<br><strong>优点</strong>：空闲分区在内存中分配均匀，查找时间短。<br><strong>缺点</strong>：缺乏大的内存空间。</li><li><strong>最佳适应算法</strong><br>最佳适应（Best Fit, BF）算法是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。<br><strong>优点</strong>：提高内存利用率，保留大空闲区。<br><strong>缺点</strong>：仍然存在小片无法利用的空闲分区（碎片）。</li></ul></li><li>动态可重定位分区分配<br>对内存中正在使用的分区进行搬迁，使多个小的空闲分区（碎片）合并为一个大的空闲分区。<br><img src="http://p9ucdlghd.bkt.clouddn.com/pelocatable-partition.png" alt="pelocatable-partition"></li></ul><h3 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h3><ul><li>页面：逻辑上的划分，进程空间管理上的划分，简称页。页是操作系统分配内存的最小单位。</li><li>物理块：物理上的划分。</li></ul><p><strong>页</strong>与<strong>物理块</strong>的关系：</p><ul><li>页的大小与物理块大小完全相等。</li><li>进程任何一个页都可以装入内存的任何一个物理块。</li><li>进程除了最后一个页可能会产生碎片，其他页都是刚好装入各个物理块中。</li><li>各个页离散地分布在不同物理块中。</li><li>页的编号在逻辑地址上是连续的，在物理块分布上是离散的。</li></ul><p><img src="http://p9ucdlghd.bkt.clouddn.com/paging.png" alt="paging"></p><p><strong>页表</strong>记录了进程每一页在内存存放的块号。页内地址直接对应块内地址。<br><img src="http://p9ucdlghd.bkt.clouddn.com/page-table.png" alt="page-table"></p><p>地址转换机构：<br>地址转换是将用户空间中的<strong>逻辑地址</strong>转换为内存空间中的<strong>物理地址</strong>。而页内地址与物理地址一一对应，因此地址变换机构的任务的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号。<br><img src="http://p9ucdlghd.bkt.clouddn.com/address-conversion.png" alt="address-conversion"></p><h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><p>分段是指将一个进程划分为多个具有逻辑意义而且相对独立的部分。例如主程序段、数据段、堆栈段、子程序段等……<br>每个段都有独立的名称，为了管理方便，用段号表示。在逻辑地址意义上，每个段包含两部分：段号、段内地址。<br><img src="http://p9ucdlghd.bkt.clouddn.com/segmentation.png" alt="segmentation"><br>作业空间与内存空间的映射，借助于段表：<br><img src="http://p9ucdlghd.bkt.clouddn.com/segment-table.png" alt="segment-table"><br>😀<strong>分页</strong>与<strong>分段</strong>的区别：</p><ul><li><strong>页是信息的物理单位</strong>，满足<strong>系统空间管理需要</strong>，分页实现离散分配方式，以消减内存的外零头， 提高内存的利用率；<br><strong>段是信息的逻辑单位</strong>，每个段含有一组意义完全的信息，分段是为了满足程序员在编写代码时的一些逻辑需求，比如数据共享、数据保护。</li><li><strong>页的大小固定</strong>，由<strong>系统</strong>决定；<strong>段的长度不固定</strong>， 由<strong>用户</strong>决定。</li></ul><h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><p>段面向用户程序需要，段长度不固定；<br>段需要连续分配空间，存在连续分配的缺点，例如易产生碎片；<br>结合段式和页式两者管理优点，既能节省内存空间，提高内存分配效率；又能兼顾用户程序需要。</p><p>段页式管理机制：</p><ul><li>分段与分页机制的结合；</li><li>先将用户程序划分为多个有逻辑意义的段，再将段划分为多个页；</li><li>段页式管理需要设置段表和页表；</li><li>每个段都对应一张页表，因此段表存放了每张页表的开始地址和页表长度。</li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就会发生缺页中断，从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中<strong>调出一个页面到磁盘对换区</strong>，从而腾出空间给要访问的页面。</p><p><strong>页面置换算法</strong>是为了找出以后不再访问的页面或者较长时间不再使用的页面，达到具有较低的页面更换频率（低缺页率）的目标。</p><ul><li>最佳置换算法<br>该算法所选择的换出页在未来<strong>最长一段时间内不再被访问</strong>，通常可以保证获得最低的缺页率。但这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。<br><img src="http://p9ucdlghd.bkt.clouddn.com/optimal-page-replacement-algorithm.png" alt="optimal-page-replacement-algorithm"></li><li>先进先出页面置换算法<br>该算法<strong>淘汰最先进入内存的页面</strong>，即选择内存驻留时间最长的，只看“进入顺序”。<br>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。<br><img src="http://p9ucdlghd.bkt.clouddn.com/fifo-page-replacement-algorithm.png" alt="fifo-page-replacement-algorithm"></li><li><p>最近最久未使用置换算法<br>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 算法选择最近最久未使用的页面，增加访问字段(t)记录各个页面未被访问的周期数。<br><img src="http://p9ucdlghd.bkt.clouddn.com/lru-page-replacement-algorithm.png" alt="lru-page-replacement-algorithm"><br>LRU 置换算法<strong>需要硬件支持</strong>，硬件（移位寄存器/栈）需要解决以下两个问题：</p><ul><li>进程各个页面有多久未被访问；</li><li><p>如何快速找到最近最久未使用的页面。</p><p>😀<strong>移位寄存器</strong>：</p></li><li>每个寄存器记录进程在内存中每页的使用情况；</li><li>数据格式：R=Rn-1Rn-2Rn-3….R2R1R0；</li><li>页面被访问一次，最高位<code>Rn-1</code>置 1，每隔一定时间，寄存器右移一位；</li><li><p><code>R</code>值最小的页面是被置换页。<br><img src="http://p9ucdlghd.bkt.clouddn.com/shift-register.png" alt="shift-register.png"></p><p>😀<strong>堆栈</strong>：</p></li><li>采用特殊的栈来保存当前使用的各个页面号；</li><li>栈顶保留的是最新被访问的页；</li><li>栈底保留的是最久未被访问的页，即置换目标。<br><img src="http://p9ucdlghd.bkt.clouddn.com/heap-stack.png" alt="heap-stack"></li></ul></li><li>简单 Clock 置换算法<br>该算法是 LRU 算法的近似算法，也称为<strong>最近未用</strong>算法。它为每一页设置一访问位，实际编程中用整型数组来表示当前业内是否被访问，1 代表被访问过，0 代表未访问过。<br>每次置换，指针循环遍历，找出第一个访问位为 0 的那个内存页面。若该页面访问位为 1，则将访问位置 0，指针继续移动。<br><img src="http://p9ucdlghd.bkt.clouddn.com/simple-clock-page-replacement-algorithm.png" alt="simple-clock-page-replacement-algorithm"></li><li>改进型 Clock 置换算法<br>每个页面设置有<strong>访问位 A</strong> 和<strong>修改位 M</strong>，两个位组合成四种类型的页面（见下方表格）<br>执行过程：<ul><li>从当前指针位置开始扫描循环队列，寻找第 1 类页面，<strong>不改变访问位 A</strong>，将遇到的第一个这类页面作为淘汰页；</li><li>第一步查找失败，寻找第 2 类页面，将遇到的第一个这类页面作为淘汰页。在扫描期间，所有扫描过的页面的访问位 A 都置 0；</li><li>所有 3 类页面变成 1 类页面，4 类页面变成 2 类页面；</li><li>第二步失败，重复第一步；</li><li>如果仍失败，再重复第二步，此时就一定能找到被淘汰的页。 </li></ul></li></ul><table><thead><tr><th>页面类别</th><th>访问位 A</th><th>访问位 M</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>最近未被访问，又未被修改，最佳淘汰页。</td></tr><tr><td>2</td><td>0</td><td>1</td><td>最近未被访问，但已被修改页。</td></tr><tr><td>3</td><td>1</td><td>0</td><td>最近已被访问， 但未被修改。</td></tr><tr><td>4</td><td>1</td><td>1</td><td>最近已被访问且被修改，最不应淘汰页。</td></tr></tbody></table><ul><li>最少使用算法<br>最少使用（Least Frequently Used, LFU）置换算法对每个页面设置一个字段（移位寄存器），用来记录页面被访问的频率。</li></ul><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><p>磁盘由多个盘片组成，每个盘片分为两个盘面，每个盘面分若干个磁道（同心圆），每个磁道分若干个扇区。<br><img src="http://p9ucdlghd.bkt.clouddn.com/disk.png" alt="disk"></p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><ul><li>先来先服务<br>每个请求按照时间顺序来处理。缺点是平均寻道距离较大。<br><img src="http://p9ucdlghd.bkt.clouddn.com/first-come-first-served-disk.png" alt="first-come-first-served"></li><li>最短寻道时间优先<br>平均寻道时间较短。缺点是：“饥饿”现象，即某些进程长期得不到访问；“磁臂粘着”现象，即磁头可能长期停留在同一磁道。<br><img src="http://p9ucdlghd.bkt.clouddn.com/shortest-seek-time-first.png" alt="shortest-seek-time-first"></li><li>扫描<br>SCAN，又称为电梯调度算法，针对最短寻道优先的“饥饿”现象进行改进，依据磁头移动方向访问当前磁道最近的目标磁道。<br><img src="http://p9ucdlghd.bkt.clouddn.com/scan.png" alt="scan"></li><li>循环扫描<br>CSCAN，到达最外磁道后，返回最内磁道开始扫描。磁头移动方向固定不变，不会中途折返。优点是不会出现“饥饿”现象，平均寻道时间较短，最长等待时间比扫描算法少一半。缺点是“磁臂粘着现象仍未解决。<br><img src="http://p9ucdlghd.bkt.clouddn.com/cscan.png" alt="cscan.png"></li><li>N-Step-SCAN 算法<br>为了解决“磁臂粘着”现象，将请求序列划分为多个子序列，新请求只能进入后面的子序列，不能进入当前子序列，避免粘着现象。</li><li>FSCAN 算法<br>N-Step-SCAN 算法的简化版，只划分两个子序列，一个当前序列，一个后备序列。</li></ul><hr><p>🤭 操作系统知识总结系列完~<br>👉 <a href="/2018/07/04/all-os2">Previous</a>.</p>]]></content>
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统知识总结2</title>
      <link href="/2018/07/04/all-os2/"/>
      <url>/2018/07/04/all-os2/</url>
      <content type="html"><![CDATA[<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ul><li>高级调度（作业调度）<br>根据调度算法和计算机状态，从外存选择一个或多个作业调入内存。<ul><li>创建进程</li><li>分配内存等资源</li><li>将进程放入就绪队列等待 CPU 调度。</li></ul></li></ul><a id="more"></a><ul><li>低级调度（进程调度）<br>它决定哪个进程获得 CPU。<ul><li>保存现场</li><li>调度新进程</li><li>新进程获得 CPU 控制权</li></ul></li><li>中级调度（内存调度）<br>中级调度是为了提高内存利用率和系统吞吐量。为此，把那些暂时不能运行的进程调至外存等待，此时进程的状态为<strong>挂起状态</strong>。当它们具备运行条件且内存又稍有空闲时，再重新调入内存，并修改器状态为就绪状态。</li></ul><h3 id="三级调度队列模型"><a href="#三级调度队列模型" class="headerlink" title="三级调度队列模型"></a>三级调度队列模型</h3><p><img src="http://p9ucdlghd.bkt.clouddn.com/three-level-dispatch.png" alt="three-level-dispatch"></p><h3 id="处理机调度常见名词"><a href="#处理机调度常见名词" class="headerlink" title="处理机调度常见名词"></a>处理机调度常见名词</h3><ul><li>到达时间：进入系统的时间</li><li>开始时间：首次使用 CPU 的时间</li><li>服务时间：需要使用 CPU 的时间，也叫“运行时间”</li><li>完成时间：退出系统的时间</li><li>周转时间：完成时间 - 到达时间</li><li>带权周转时间：周转时间 / 服务时间</li><li>平均周转时间：周转时间的平均值</li><li>平均带权周转时间：带权周转时间的平均值</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><strong>先来先服务调度算法</strong><br>先来先服务（First-Come First-Served, FCFS）调度算法按照作业到达的先后次序进行调度，它优先考虑在系统中等待时间最长的作业。（不利于短作业）<br>FCFS 算法在单处理机系统中已很少作为主调度算法，但<strong>经常把它与其它调度算法相结合</strong>使用，形成更有效的调度算法。例如可以在系统中按进程的优先级设置多个队列，每个优先级一个队列，其中每一个队列的调度算法都基于 FCFS 算法。<br><img src="http://p9ucdlghd.bkt.clouddn.com/first-come-first-served.png" alt="first-come-first-served"></li><li><strong>短作业优先调度算法</strong><br>短作业优先（Short Job First, SJF）调度算法以作业的长短来计算优先级，它从外存的后备队列中<strong>选择若干个估计运行时间最短的作业</strong>，<strong>优先将它们调入内存</strong>运行。（不利于长作业，未考虑作业的紧迫程度）<br><img src="http://p9ucdlghd.bkt.clouddn.com/short-job-first.png" alt="short-job-first"></li><li><strong>优先级调度算法</strong><br>前面两种算法不能反映作业的紧迫程度，在优先级调度算法（Priority-Scheduling Algorithm, PSA）中，则是<strong>基于作业的紧迫程度</strong>，由<strong>外部赋予作业相应的优先级</strong>，调度算法是根据该作业的优先级进行调度的。</li><li><strong>高响应比优先调度算法</strong><br>高响应比优先调度算法（Highest Response Ratio Next, HRRN）既考虑了作业的等待时间，又考虑了额作业的运行时间。<br><strong>优先权 = (等待时间 + 服务时间) / 服务时间</strong><br>等待时间相同，服务时间越短优先权越高；服务时间相同，等待时间越长优先权越高。（每次调度前都要计算优先权，增加系统开销）</li><li><strong>基于时间片的轮转调度算法</strong><ul><li>将所有就绪进程按先来先服务排成队列</li><li>把 CPU 分配给队首进程，进程只执行一个时间片</li><li>时间片用完，OS 通过计时器发出时钟中断，停止进程</li><li>将已使用时间片的进程送至就绪队列末尾</li><li>分配 CPU 给就绪队列的下一个进程</li></ul></li><li><strong>多级反馈队列调度算法</strong><br>设置多个就绪队列，各个队列优先级逐个降低，时间片长度成倍增加。即，优先级越高的队列执行时间片就越短。<br>多级反馈队列调度算法的<strong>调度规则</strong>：<ul><li>每个新进程首先进入第一个队列，遵循 FCFS。</li><li>在当前队列的时间片内，进程若能完成，退出。</li><li>进程若未完成，降到第二个队列，同样遵循 FCFS。</li><li>依此类推……</li><li>低级队列只有等高级队列变空才能执行。</li><li>当高级队列有新进程进入，而当前正在运行低级队列的进程，将立即发生抢占，被抢占进程放回低级队列的末尾，记录进程剩余运行时间和在当前队列的剩余使用时间。<br><img src="http://p9ucdlghd.bkt.clouddn.com/multilevel-feedback-queue.png" alt="multilevel-feedback-queue"></li></ul></li></ul><h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><p>在实时系统中，可能存在着一些实时任务，它们都联系着一个截止时间。为保证系统能正常工作，实时调度必须能满足实时任务对截止时间的要求。</p><ul><li><strong>最早截止时间优先算法</strong><br>最早截止时间优先（Earliest Deadline First, EDF）算法是根据任务的截止时间确定任务的优先级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队列的队首。</li><li><strong>最低松弛度优先算法</strong><br>最低松弛度优先（Least Laxity First, LLF）算法是根据任务紧急程度确定任务的优先级，任务的紧急程度越高，优先级就越高。<br>松弛度 = 完成截止时间- 运行时间(服务时间) - 当前时间<br>例如，任务 A 的完成截止时间是第 400s，运行时间为 100s，当前时间是第 150s，则 A 的松弛度 = 400-100-150 = 150s<blockquote><p>在松弛度为 0 的时刻设置“地雷”，松弛度为 0 发生抢占。</p></blockquote></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ul><li>互斥<br>进程对所分配的资源进行排它性使用，即在一段时间内，某资源只能被一个进程占用。如果此时还有其它进程请求该资源，则请求进程只能等待，直到占有该资源的进程释放。</li><li>请求与保持<br>进程已经持有了至少一个资源，但又提出新的资源请求。</li><li>不可剥夺<br>已获得的资源在使用完之前，不能被抢占，只能在进程使用完自己释放。</li><li>环路等待<br>存在一个“进程——资源”循环链，进程间互相等待资源。</li></ul><h3 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h3><ul><li>预防死锁<br>设置限制条件，破坏产生死锁的一个或多个必要条件。比如，强制回收资源、资源一次性分配……</li><li>避免死锁<br>在资源动态分配过程中，加入检查，防止系统进入不安全状态。</li><li>检测死锁<br>建立检测机构检测死锁的发生和原因，确定相关的进程和资源。</li><li>解除死锁<br>剥夺资源或撤销进程，从而解除死锁。</li></ul><h3 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h3><p>在死锁避免方法中，把系统的状态分为<strong>安全状态</strong>和<strong>不安全状态</strong>。当系统处于安全状态时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。<br>所谓安全状态，是指系统能按某种进程顺序 &lt;P1, P2, …，Pn&gt; 来为每个进程<code>Pi</code>分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成，称 &lt;P1, P2, …, Pn&gt; 序列为安全序列。<br>如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><p>数据结构的定义：</p><table><thead><tr><th>定义</th><th>描述</th></tr></thead><tbody><tr><td>Max</td><td>进程对各种资源的最大需求</td></tr><tr><td>Allocation</td><td>进程已占用（分配）的各种资源的数量</td></tr><tr><td>Need</td><td>进程对各种资源的剩余需求量</td></tr><tr><td>Available</td><td>系统当前可用资源数量</td></tr><tr><td>Work</td><td>每个进程完成后系统可用资源数量<br>（初始值为 Available）</td></tr><tr><td>Finish</td><td>每个进程能否完成</td></tr></tbody></table><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>银行家算法原本是为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。<br>当<strong>进程请求一组资源</strong>时，系统必须<strong>首先确定是否有足够的资源分配给该进程</strong>。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全的状态。如果不会，才将资源分配给它。<br>判断方法：</p><ol><li><strong>虚拟执行</strong>这个分配请求，使得当前状态进入下一个状态；</li><li>在下一个状态中寻找安全序列；</li><li>若找到，说明状态安全，可以执行分配请求；否则拒绝分配请求。</li></ol><p><img src="http://p9ucdlghd.bkt.clouddn.com/banker-algorithm.png" alt="banker-algorithm"><br>算法缺点：</p><ul><li>很少进程能够在运行前就知道它所需资源的最大值。</li><li>系统内的进程数是不固定的，往往在不断变化，有新的进入，有完成的退出。</li></ul><hr><p>😄 To be continued.<br>👉 <a href="/2018/07/04/all-os3">Next</a>.<br>👉 <a href="/2018/07/01/all-os">Previous</a>.</p>]]></content>
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统知识总结</title>
      <link href="/2018/07/01/all-os/"/>
      <url>/2018/07/01/all-os/</url>
      <content type="html"><![CDATA[<h2 id="操作系统概论"><a href="#操作系统概论" class="headerlink" title="操作系统概论"></a>操作系统概论</h2><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ul><li>作为用户与计算机硬件系统之间的接口。</li><li>作为计算机系统资源的管理者。</li><li>实现对计算机资源的抽象。</li></ul><h3 id="操作系统的四个基本特性"><a href="#操作系统的四个基本特性" class="headerlink" title="操作系统的四个基本特性"></a>操作系统的四个基本特性</h3><a id="more"></a><ul><li>并发<br>在一段时间内多个程序并发执行。</li><li>共享<br>系统中的资源可以被内存中多个并发执行的进线程共同使用。</li><li>虚拟<br>通过分时系统以及虚拟内存技术实现<strong>把一个物理实体虚拟为若干个逻辑上的对应物</strong>。</li><li>异步<br>系统中的进程以不可预知的速度向前推进，但只要运行环境相同，多次运行都会获得完全相同的结果。</li></ul><h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><ul><li>处理机管理：进程控制、进程同步、进程通信、CPU 调度</li><li>存储器管理：内存分配、地址映射</li><li>设备管理：缓冲管理、设备分配、设备处理、虚拟设备</li><li>文件管理：存储空间管理、目录管理</li><li>用户接口：图形接口、命令接口</li></ul><h2 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h2><h3 id="程序顺序执行的特征"><a href="#程序顺序执行的特征" class="headerlink" title="程序顺序执行的特征"></a>程序顺序执行的特征</h3><ul><li>顺序性：下一操作要等待前一操作执行结束。</li><li>封闭性：执行独占资源，不受外界影响。</li><li>可再现性：重复执行得到相同结果。</li></ul><h3 id="程序并发执行的特征"><a href="#程序并发执行的特征" class="headerlink" title="程序并发执行的特征"></a>程序并发执行的特征</h3><ul><li>间断性</li><li>失去封闭性 </li><li>不可再现性：重复执行可引发多种结果。</li></ul><p>程序并发的三个特征使得程序不能并发地正确执行，为了保证程序并发执行，引入进程。</p><h3 id="进程的结构"><a href="#进程的结构" class="headerlink" title="进程的结构"></a>进程的结构</h3><p><strong>进程</strong>由程序、数据、进程控制块(PCB)三部分组成。</p><ul><li>程序：代码段，描述进程要完成的功能。</li><li>数据：数据段，进程执行时所需要的数据区。</li><li>进程控制块：一种数据结构，用于标识进程的存在，记录进程执行过程中各个时刻的状态特征。</li></ul><h3 id="进程的四个特性"><a href="#进程的四个特性" class="headerlink" title="进程的四个特性"></a>进程的四个特性</h3><ul><li>动态：进程具有生命周期，从创建，执行，到消亡。</li><li>并发：多个进程共存于内存中，并发执行。</li><li>独立：进程间资源独立，互不干扰。进程是<strong>系统进行资源分配和调度的一个独立单位</strong>。</li><li>异步：每个进程都以其相对独立，不可预知的速度前进。</li></ul><h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><ul><li>进程是动态的执行实体，程序是静态的数据与指令的集合。</li><li>一个程序可以包含多个进程。</li><li>进程用于并发执行与接受调度，程序用于存储数据和接受系统启动。</li><li>进程执行需要 CPU，程序存储需要存储器。</li><li>进程具有生命周期，程序是永存的。</li></ul><h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><ul><li>就绪状态：已获得除 CPU 以外的其他所有资源，处于就绪队列，等待 CPU 调度。</li><li>执行状态：获得 CPU，处于执行过程。</li><li>阻塞状态：某个事件暂时无法进行，主动放弃 CPU。</li></ul><p><img src="http://p9ucdlghd.bkt.clouddn.com/process-status.png" alt="process-status"></p><h3 id="PCB-的作用"><a href="#PCB-的作用" class="headerlink" title="PCB 的作用"></a>PCB 的作用</h3><p>PCB 中包含进程标识符、处理机状态、进程调度信息、进程控制信息。所以 PCB 具有以下作用：</p><ul><li>进程存在的唯一标识</li><li>记录进程的外部特征</li><li>描述进程变化的过程</li><li>记录进程和其他进程的联系</li></ul><h3 id="PCB-的组织方式"><a href="#PCB-的组织方式" class="headerlink" title="PCB 的组织方式"></a>PCB 的组织方式</h3><ul><li><strong>链接方式</strong>：把具有相同状态的进程的 PCB 分别通过 PCB 中的链接字段链接成一个队列。优先级高的进程 PCB 排在队列前面。<br><img src="http://p9ucdlghd.bkt.clouddn.com/pcb-link.png" alt="pcb-link"></li><li><strong>索引方式</strong>：根据进程状态的不同建立索引。<br><img src="http://p9ucdlghd.bkt.clouddn.com/pcb-index.png" alt="pcb-index"></li></ul><h3 id="原语操作"><a href="#原语操作" class="headerlink" title="原语操作"></a>原语操作</h3><p><strong>原语</strong>由若干指令组成，是用于完成一定功能的一个过程。<br>原语操作是一种原子操作；原语中的操作要么全做，要么全不做。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><ol><li>申请空白 PCB；</li><li>为新进程分配资源；</li><li>初始化 PCB；</li><li>如果进程就绪队列能够接纳新进程，就将新进程插入就绪队列。</li></ol><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ol><li>根据标识符从 PCB 集合中检索出 PCB，读取进程状态；</li><li>若正处于执行状态，立即终止该进程的执行，并<strong>置调度标志位真</strong>，在进程被终止后重新调度；</li><li>终止该进程的子孙进程，以防止成为不可控的进程；</li><li>回收资源，归还给父进程/系统；</li><li>PCB 移出所在队列或链表。</li></ol><h3 id="进程阻塞（对应唤醒）"><a href="#进程阻塞（对应唤醒）" class="headerlink" title="进程阻塞（对应唤醒）"></a>进程阻塞（对应唤醒）</h3><p>执行过程中，当发现引发阻塞的事件而无法继续执行时，进程调用阻塞原语<code>block</code>把自己阻塞。</p><ol><li>停止当前执行；</li><li>修改状态，由执行改为阻塞；</li><li>将 PCB 插入阻塞队列，若有因不同事件而划分的多个阻塞队列，阻塞进程插入相应队列；</li><li>重新调度，将处理机分配给另一就绪进程；</li><li>CPU 环境切换，保存被阻塞进程的 CPU 状态到 PCB 中，按新进程 PCB 的 CPU 状态设置 CPU 新环境。</li></ol><h3 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h3><p>被阻塞的事件已满足，如 I/O 完成或所需数据已到达，则由有关进程调用唤醒原语<code>wakeup</code>，将阻塞的进程唤醒：</p><ol><li>先把被阻塞的进程从等待该事件的阻塞队列中移出；</li><li>将其 PCB 状态由阻塞改为就绪；</li><li>再将该 PCB 插入到就绪队列中。</li></ol><h3 id="进程挂起（对应激活）"><a href="#进程挂起（对应激活）" class="headerlink" title="进程挂起（对应激活）"></a>进程挂起（对应激活）</h3><p>挂起是将<strong>活动状态</strong>改为<strong>静止状态</strong>的过程。</p><p>挂起一般有以下几个原因：</p><ul><li>终端用户的请求：当终端用户发现自己程序运行期间有可疑进程时，需要挂起检查。</li><li>父进程的请求：有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。</li><li>负载调节的需要：保证系统正常运行。</li><li>操作系统的需要：操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况。</li></ul><p>挂起原语的执行过程如下：</p><ol><li>检查被挂起进程的状态，活动就绪改为静止就绪；活动阻塞改为静止阻塞；</li><li>将 PCB 复制到指定的内存区域；</li><li>数据复制到外存，释放内存；</li><li>若被挂起的进程正在执行，则重新调度。</li></ol><h3 id="进程激活"><a href="#进程激活" class="headerlink" title="进程激活"></a>进程激活</h3><p>当发生激活进程的事件，如父进程或用户进程请求激活，或当前内存有足够的空间，系统利用激活原语<code>active</code>将进程激活。</p><p>激活原语的执行过程如下：</p><ol><li>先将进程从外存调入内存；</li><li>检查该进程的现行状态，静止就绪改为活动就绪；静止阻塞改为活动阻塞；</li><li>若是进入就绪队列，则重新调度，抢占式和非抢占式调度。</li></ol><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步的任务是使并发执行的诸进程之间能有效地共享资源和相互合作，从而使进程的执行具有可再见性。<br>同步机制应遵循的规则：</p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ul><li>整型信号量<br>使用一个代表资源数目的整型变量。未遵循“让权等待”规则。</li><li>记录型信号量<br><strong>增加一个进程链表 L</strong>，用于链接所有等待进程。<br>初始值为 1，表示只允许一个进程访问临界资源，此时的信号量转换为互斥信号量。</li><li>AND 型信号量<br>将进程在整个运行过程中需要的所有资源，一次分配给进程，待进程使用完后再一起释放。即：要么全部分配到进程，要么一个也不分配。</li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是一种<strong>共享数据结构</strong>，对该共享数据结构实施的特定操作定义为<strong>一组过程</strong>。进程对共享资源的申请、释放和其他操作必须通过这组过程。</p><ul><li>局部数据变量<strong>只能被管程的过程访问</strong>，任何外部过程都不能访问。</li><li>一个进程通过调用管程的一个过程进入管程。</li><li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其它进程都被阻塞。</li></ul><h3 id="生产者——消费者问题"><a href="#生产者——消费者问题" class="headerlink" title="生产者——消费者问题"></a>生产者——消费者问题</h3><p>可以利用“记录型信号量、AND 型信号量、管程”来解决生产者——消费者问题，这里演记录型信号量的使用。<br>假设有<code>n</code>个缓冲区。</p><table><thead><tr><th>变量</th><th>功能/描述</th></tr></thead><tbody><tr><td>mutex</td><td><strong>实现</strong>诸进程对缓冲区的<strong>互斥</strong>访问（公有）</td></tr><tr><td>empty</td><td>缓冲池中<strong>空缓冲区的数量</strong>（私有）</td></tr><tr><td>full</td><td>缓冲池中<strong>满缓冲区的数量</strong>（私有）</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">producer:begin</span><br><span class="line">    repeat</span><br><span class="line">        produce an item nextp;</span><br><span class="line">        wait(empty); <span class="comment">// 先私</span></span><br><span class="line">        wait(mutex); <span class="comment">// 后公</span></span><br><span class="line">        buffer(<span class="keyword">in</span>) ∶= nextp;</span><br><span class="line">        <span class="keyword">in</span> ∶= (<span class="keyword">in</span> + <span class="number">1</span>) mod n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);</span><br><span class="line">        until <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">consumer:begin</span><br><span class="line">    repeat</span><br><span class="line">        wait(full); <span class="comment">// 先私</span></span><br><span class="line">        wait(mutex); <span class="comment">// 后公</span></span><br><span class="line">        nextc ∶= buffer(out);</span><br><span class="line">        out ∶= (out + <span class="number">1</span>) mod n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line">        consume the item <span class="keyword">in</span> nextc;</span><br></pre></td></tr></table></figure><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>五个哲学家进餐，如何<strong>避免死锁</strong>？</p><ul><li>至多只允许有四位哲学家同时去拿左边的筷子</li><li>当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。</li><li>规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。</li></ul><h3 id="读者——写者问题"><a href="#读者——写者问题" class="headerlink" title="读者——写者问题"></a>读者——写者问题</h3><ul><li>一个数据文件可被多个进程共享</li><li>允许多个进程同时读，禁止多个进程同时写</li><li>当一个进程写的时候，其他所有读进程都要停止</li><li>当进程读的时候，不允许写进程的发生。</li><li>读写是互斥的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmutex, <span class="attr">wmutex</span>:semaphore = <span class="number">1</span>, <span class="number">1</span>;</span><br><span class="line">    readcount:integer = <span class="number">0</span>;</span><br><span class="line">    begin</span><br><span class="line">    parbegin</span><br><span class="line">    reader:begin</span><br><span class="line">        repeat</span><br><span class="line">            wait(rmutex);</span><br><span class="line">            <span class="keyword">if</span> readcount = <span class="number">0</span> then wait(wmutex);</span><br><span class="line">            readcount ∶= readcount + <span class="number">1</span>;</span><br><span class="line">            signal(rmutex);</span><br><span class="line">            perform read operation;</span><br><span class="line"></span><br><span class="line">            wait(rmutex);</span><br><span class="line">            readcount = readcount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> readcount = <span class="number">0</span> then signal(wmutex);</span><br><span class="line">            signal(rmutex);</span><br><span class="line">        until <span class="literal">false</span>;</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">    writer:begin</span><br><span class="line">        repeat</span><br><span class="line">            wait(wmutex);</span><br><span class="line">            perform write operation;</span><br><span class="line">            signal(wmutex);</span><br><span class="line">        until <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程间通信（IPC, InterProcess Communication）是指在不同进程之间传播或交换信息。</p><h3 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h3><ul><li>共享内存（最快）<br>同一块物理内存<strong>被映射到</strong>进程 A、进程 B 各自的进程空间。进程 A 可以即时看到进程 B 对共享内存中数据的更新，反之亦然。<br>由于多个进程共享同一块内存区域，必然需要使用<strong>同步机制</strong>，互斥锁和信号量都可以。</li><li>管道<br>管道是指用于连接一个读进程和一个写进程以实现它们之间通信的一个<strong>共享文件</strong>，又叫<code>pipe</code>文件。<br><strong>写进程</strong>：以字符流形式将大量的数据送入共享文件，即送入管道。<br><strong>读进程</strong>：从管道中接收数据，即从共享文件中读数据。<br>管道只支持<strong>半双工通信</strong>（单向传输）；<strong>只能在父子进程中使用</strong>；管道实质是采用文件的读写操作，支持大数据量的传输。<br><img src="http://p9ucdlghd.bkt.clouddn.com/pipe.png" alt="pipe"></li><li>命名管道<br>即 FIFO 文件，通过命名管道可以实现<strong>在不相关的进程之间交换数据</strong>。</li><li>消息队列<br>消息队列提供了一种<strong>从一个进程向另一个进程发送一个数据块</strong>的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。<br>相比于 FIFO，<strong>消息队列具有以下优点</strong>：<ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，<strong>不需要进程自己提供同步方法</strong>；</li><li>读进程可以<strong>根据消息类型有选择地接收消息</strong>，而不像 FIFO 那样只能默认地接收。</li></ul></li><li>套接字<br>与其它通信机制不同的是，它可用于不同机器间的进程通信。</li></ul><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ul><li>地址空间<br>进程之间是独立的地址空间，而同一进程的线程则共享本进程的地址空间。</li><li>资源拥有<br>进程之间的资源是独立的，而同一进程内的线程共享本进程的资源，如内存、I/O、CPU 等。<br>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃后整个进程都死掉。所以多进程要比多线程健壮。</li><li>执行过程<br>每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口，而线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>线程是处理机调度的基本单位，但是进程不是。</li></ul><p>因此，<br>对资源的管理和保护要求高、不限制开销和效率时，使用多进程。<br>要求效率高、频繁切换、资源的保护管理要求不是很高时，使用多线程。</p><hr><p>😄 To be continued.<br>👉 <a href="/2018/07/04/all-os2">Next</a>.</p>]]></content>
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络——应用层</title>
      <link href="/2018/06/30/application-layer/"/>
      <url>/2018/06/30/application-layer/</url>
      <content type="html"><![CDATA[<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>HTTP 协议（HyperText Transfer Protocal, 超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传送协议。它基于 TCP 协议之上，属于<strong>应用层协议</strong>。</p><h3 id="HTTP-请求响应模型"><a href="#HTTP-请求响应模型" class="headerlink" title="HTTP 请求响应模型"></a>HTTP 请求响应模型</h3><p>HTTP 是一个<strong>无状态的协议</strong>。无状态是指客户端和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器发送请求，服务器返回响应之后，连接即关闭了，在服务端不保留连接的有关信息。</p>]]></content>
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络——传输层</title>
      <link href="/2018/06/29/transport-layer/"/>
      <url>/2018/06/29/transport-layer/</url>
      <content type="html"><![CDATA[<h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><p>在 OSI（Open System Interconnection, 开发系统互联）七层模型中，传输层是面向通信的最高层，也是面向用户功能的最底层。<br><img src="http://p9ucdlghd.bkt.clouddn.com/osi.gif" alt="osi"></p><a id="more"></a><p>传输层有两大功能：</p><ul><li>复用：在发送端，多个应用进程共有一个传输层。</li><li>分用：在接收端，传输层根据端口号将数据分派给不同的应用进程。</li></ul><p>传输层和网络层的<strong>区别</strong>：</p><ul><li>网络层是为<strong>不同主机</strong>提供通信服务，而传输层是为<strong>不同主机的不同应用程序</strong>提供通信服务。</li><li>网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。</li></ul><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><h3 id="UDP-的特点"><a href="#UDP-的特点" class="headerlink" title="UDP 的特点"></a>UDP 的特点</h3><p>UDP（User Datagram Protocol, 用户数据报协议）有以下特点：</p><ul><li>无连接<br>通信前不需要建立连接，通信结束也无须释放连接。</li><li>不可靠<br>UDP 是尽力而为交付，不能确保每个数据报都送达。</li><li>面向报文<br>UDP 数据传输的基本单位是<strong>报文</strong>，它不会对数据做任何拆分或拼接操作。<br>在<strong>发送端</strong>，应用程序给传输层的 UDP 什么数据，UDP 不会对数据进行拆分，只增加一个 UDP 头后就交给网络层；<br>在<strong>接收端</strong>，UDP 收到网络层的数据报后，不会作任何拼接操作，去掉数据报头后便交给应用层。</li><li>没有拥塞控制<br>UDP 始终以恒定的速率发送数据，它不会根据网络拥塞情况对发送速率作出调整。<br>这种方式可能导致数据丢失，但可以应用在“直播、语音通话”这种允许数据丢失、但对实时性要求较高的场景。</li><li>支持一对一、一对多、多对一、多对多通信</li><li>首部开销小，只有 8 字节</li></ul><h3 id="UDP-头部"><a href="#UDP-头部" class="headerlink" title="UDP 头部"></a>UDP 头部</h3><p>UDP 头部只有 8 字节，包括：</p><ul><li>16 位源端口</li><li>16 位目的端口</li><li>16 位 UDP 长度</li><li>16 位 UDP 检验和</li></ul><p><img src="http://p9ucdlghd.bkt.clouddn.com/udp-header.jpg" alt="udp-header"></p><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="TCP-的特点"><a href="#TCP-的特点" class="headerlink" title="TCP 的特点"></a>TCP 的特点</h3><p>TCP（Transmission Control Protocol, 传输控制协议）有以下特点：</p><ul><li>面向连接<br>通信前需要建立连接，通信结束后需要释放连接。</li><li>可靠<br>TCP 发送的数据无重复、无丢失、与发送端顺序一致。</li><li>面向字节流<br>TCP 以字节位单位，传输的过程中数据被划分成一个个数据报。</li><li>全双工通信<br>TCP 的两端既可以作为发送端，也可以作为接收端。</li><li>一条 TCP 连接的两端只能有两个端点<br>TCP 只能提供点到点的通信，而 UDP 可以任意方式的通信。一条 TCP 连接的两端就是两个套接字，套接字 = IP: 端口号。</li></ul><h3 id="TCP-头部"><a href="#TCP-头部" class="headerlink" title="TCP 头部"></a>TCP 头部</h3><p>TCP 头部通常有 20 字节，有选项时更长，但总共不超过 60 字节。包括：</p><ul><li>源端口、目的端口（共 4 字节）<br>传输层和网络层的一大重要区别就是：传输层指定了数据报发往的应用进程，因此需要端口号标识。</li><li>序号（4 字节）<br>当前 TCP 数据报数据部分的第一个字节的序号。<br>TCP 是面向字节流的，它会对发送的每一个字节进行编号，而且不同数据报之间是连续编号的。</li><li>确认号（4 字节）<br>表示当前主机作为接收端，期望接收的下一个字节的编号。</li><li>数据偏移（4 字节）<br>数据部分距离报文段起始部分的偏移，其实就是头部的长度。</li><li>保留字段</li><li>标识符<ul><li>URG：该字段被置 1 时，表示当前数据报的数据部分包含紧急信息，紧急数据一定是在数据部分的最前面，紧急指针标明了紧急数据的尾部。</li><li>ACK：该字段被置 1 时，确认号字段才有效。在连接建立后传送的所有报文短都必须把 ACK 置 1。</li><li>PSH：当接收方收到 PSH=1 的报文后，会立即将数据交给应用程序，而不是等到缓冲区满了后才提交。</li><li>RST：该值为 1 时，表示当前 TCP 连接出现严重问题，需要释放重连。</li><li>SYN：SYN 在<strong>建立连接的时候使用</strong>。（SYN=1, ACK=0）表示当前报文段是一个连接请求报文；（SYN=1, ACK=1）表示当前报文是一个同意建立连接的应答报文。</li><li>FIN：FIN=1 表示此报文段是一个<strong>释放连接的请求报文</strong>。</li></ul></li><li>接收窗口大小<br>表示当前接收窗口的剩余容量大小，用于实现 TCP 的流量控制。发送方收到该值后会将发送窗口调整为该值的大小。发送窗口的大小又影响了发送速率，所以接收方通过设置该值控制发送方的发送速率。</li><li>检验和<br>用于接收端检验整个数据报在传输过程中是否出错。</li><li>紧急指针<br>用于标识紧急数据的尾部。</li><li>选项字段<br>长度可选。</li></ul><p><img src="http://p9ucdlghd.bkt.clouddn.com/tcp-header.png" alt="tcp-header"></p><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>假设 A 为客户端，B 为服务端。</p><ul><li>首先 B 处于<code>LISTEN</code>状态，等待 A 的连接请求。</li><li>A 向 B 发送请求报文， （SYN=1, ACK=0），发送后 A 进入<code>SYN-SENT</code>状态。</li><li>B 收到 A 的请求报文，如果同意建立连接，则向 A 发送连接确认报文段，（SYN=1, ACK=1），发送后 B 进入<code>SYN-RCVD</code>状态。</li><li>A 收到 B 的连接确认报文段，还要向 B 发送一个确认报文段，发送后 A 进入<code>ESTABLISHED</code>状态，B 收到后也进入<code>ESTABLISHED</code>状态，从而连接建立。</li></ul><p><img src="http://p9ucdlghd.bkt.clouddn.com/tcp-establish-connection.png" alt="tcp-establish-connection"></p><p>为什么是<strong>三次握手</strong>？而不是两次？<br>其实是防止失效的连接被服务端接收，导致服务端错误打开连接而浪费资源。<br>如果建立连接只需要两次握手，客户端没有太大变化，它在获得服务端的应答后进入<code>ESTABLISHED</code>状态，而服务端会在收到连接请求后就进入<code>ESTABLISHED</code>状态。此时如果网络拥塞，客户端发送的请求迟迟到不了服务端，客户端会超时重发，如果服务端正确接收并确认应答，双方开始通信，通信接收后释放连接。此时如果那个失效的连接请求抵达服务端，由于只有两次握手，服务端会进入<code>ESTABLISHED</code>状态，而此时客户端早已进入<code>CLOSED</code>状态，服务端会一直等待下去，从而浪费服务端连接资源。</p><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>TCP 连接的释放一共需要四步，称为“四次挥手”。前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一个方向的连接。</p><ul><li>A 发送连接释放报文段， FIN=1，之后进入<code>FIN-WAIT-1</code>状态。</li><li>B 收到后，向 A 发送连接应答，进入<code>CLOSE-WAIT</code>状态。</li><li>A 收到该应答，进入<code>FIN-WAIT-2</code>状态，等待 B 发送连接释放的请求。</li><li>当 B 不再需要连接时，向 A 发送连接释放的请求报文， FIN=1，之后 B 进入<code>LAST-ACK</code>状态。</li><li>A 收到释放请求后，向 B 发送应答，进入<code>TIME-WAIT</code>状态，等待 2MSL 后进入<code>CLOSED</code>状态，B 收到应答后，也进入<code>CLOSED</code>状态。</li></ul><p>为什么 A 要先进入<code>TIME-WAIT</code>状态，<strong>等待 2MSL 时间</strong>后再进入<code>CLOSED</code>状态？<br>其实是<strong>为了保证 B 能收到 A 的确认应答</strong>。<br>若 A 发完确认应答后直接<code>CLOSED</code>，如果该应答丢失，B 等待超时，会重新发送释放连接的请求，此时 A 已经关闭了，不会作出任何响应，B 永远无法正常关闭。</p><h3 id="TCP-可靠传输的表现"><a href="#TCP-可靠传输的表现" class="headerlink" title="TCP 可靠传输的表现"></a>TCP 可靠传输的表现</h3><p>TCP 的可靠性在于，它向应用层提供的数据是无差错、有序、无丢失的。<br>TCP 采用<strong>流量控制</strong>、<strong>拥塞控制</strong>、<strong>连续 ARQ</strong> 等技术保证它的可靠性。</p><h3 id="停止等待协议（ARQ-协议）"><a href="#停止等待协议（ARQ-协议）" class="headerlink" title="停止等待协议（ARQ 协议）"></a>停止等待协议（ARQ 协议）</h3><p>TCP 保证其可靠性采用的是更为复杂的<strong>滑动窗口协议</strong>，但停止等待协议是它的简化版，因此这里先介绍停止等待协议。<br>ARQ（Automatic Repeat reQuest, 自动重传请求），就是当请求失败时它会自动重传，直到请求被正确接收为止。</p><ul><li>无差错的情况<br>A 向 B 每发送一个分组，都要停止发送，收到 B 的确认应答后才发送下一个分组。</li><li>分组丢失、出现差错的情况<br><strong>分组丢失</strong>：分组在途中丢失，B 收不到，因此不会有响应，A 超时后会重传。<br><strong>出现差错</strong>：B 收到分组，但检查到分组有差错，会直接丢弃，不会有响应，A 同样超时重传。</li><li>应答丢失、应答迟到的情况<br><strong>应答丢失</strong>：B 收到分组，返回应答，但应答在途中丢失了，A 超时重传，紧接着 B 又收到该分组，判断该是否已接收，若已接收则直接丢弃，并补上一个应答。<br><strong>应答迟到</strong>：B 收到分组，返回应答，但由于网路拥塞，A 没有及时收到分组，导致超时重传，之后前面的应答抵达 A，A 判断是否已接收，若是则直接丢弃即可。</li></ul><h3 id="滑动窗口协议（连续-ARQ-协议）"><a href="#滑动窗口协议（连续-ARQ-协议）" class="headerlink" title="滑动窗口协议（连续 ARQ 协议）"></a>滑动窗口协议（连续 ARQ 协议）</h3><p>在 ARQ 协议中，发送者每次只能发送一个分组，在应答到来前必须等待，而连续 ARQ 协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样减少了等待时间，提高了传输的效率。</p><p><img src="http://p9ucdlghd.bkt.clouddn.com/slide-window.jpg" alt="slide-window"></p><p>窗口是缓存的一部分，用来暂时存放字节流。发送者和接收者各有一个窗口，接收者通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送者根据这个值和其它信息设置自己的窗口大小。</p><p>如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。</p><blockquote><p>TCP 协议的两端分别为发送者 A 和接收者 B，由于是全双工通信，因此 A 和 B 应该分别维护着一个独立的发送缓冲区和接收缓冲区。</p></blockquote><h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>流量控制是为了避免分组丢失，通过控制发送方发送速率，保证接收方来得及接收。它通过滑动窗口协议实现。</p><p>流量控制可能引发死锁。当发送者收到一个窗口为 0 的应答时，进入等待状态，等待接收者的下一个应答。如果下一个窗口不为 0 的应答在途中丢失，会导致发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待下去，从而产生死锁。为了<strong>避免死锁</strong>，TCP 使用了<strong>持续计时器</strong>，每当发送者收到一个 0 窗口的应答后就启动计数器，时间一到会询问接收者窗口的大小。若依然为 0，则重新启动计时器，如此下去……</p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><p>如果网络出现拥塞，分组将会丢失，此时发送者会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送者的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收者能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。</p><p>TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方需要维护一个叫做<strong>拥塞窗口</strong>（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><ul><li><p>慢开始与拥塞避免<br>发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …<br>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个<strong>慢开始门限</strong> ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。<br>如果出现了超时，则令 ssthresh = cwnd/2，然后<strong>重新执行慢开始</strong>。</p></li><li><p>快重传与快恢复<br>对于接收者，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。<br>而对于发送方，如果收到三个重复确认，那么可以确定下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。<br>在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>免费搭建属于自己的博客</title>
      <link href="/2018/06/29/build-your-own-blog/"/>
      <url>/2018/06/29/build-your-own-blog/</url>
      <content type="html"><![CDATA[<p>对于一个没有一点编程基础的同学来说，搭建这样的一个博客，难吗？</p><p>不难，说真的。但不是说很简单，它需要你去了解一些小知识点，比如 Git 命令行的使用、GitHub 仓库的创建、代码的远程部署等等……它不像我们安装某些软件一样，只要把安装包下载下来，运行安装程序，一路 next 到最后完成即可。</p><p>这篇文章里，我会大致说一下搭建的流程以及用到的每个工具的作用，但不会详细讲一步步具体该怎么操作，因为网上有太多详细的教程了，只要你会用搜索引擎。</p><a id="more"></a><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>Git 是一个版本控制软件，或者说是一个管理代码的工具，特别适合用于团队的协作开发中。在公司，一般是团队协作完成软件/系统的开发，同事把代码提交到远程仓库，你可以在自己电脑上通过 Git 命令将代码克隆下来，创建分支，加进去你的代码，提交的时候可以 merge 合并分支，协作完成开发工作。</p><p><img src="http://p9ucdlghd.bkt.clouddn.com/merge.jpg" alt="merge"></p><p>我们搭建自己的博客，需要将代码部署到 GitHub 上，用的就是 Git 的一些基本命令，比如 commit、push…</p><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>我的这个博客用的是 Hexo 框架，它基于 Node.js 开发，因此，在安装 Hexo 之前，首先需要安装 Node.js。而 npm 是 Node.js 的一个包管理工具，安装完 Node.js 之后，就有了 npm。通过 npm 我们可以把搭建博客需要的一些代码包（如 Hexo）下载下来并完成安装。</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>通过执行 npm 命令安装即可。</p><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>安装完 Hexo，在自己喜欢的文件夹下初始化 Hexo 博客，并配置一些相关信息，比如博客网站的标题、语言(zh-Hans)等等。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>这一步可以不做，你完全可以用 Hexo 的默认主题，只是我嫌弃它默认的主题样式不好看，因此安装了 nexT 主题样式，看起来舒服多了，这个过程可以做一些个性化配置，比如文章的展示方式……只要在主题文件夹下修改 <code>_config.yml</code> 文件的配置信息即可。</p><p><img src="http://p9ucdlghd.bkt.clouddn.com/config.jpg" alt="config"></p><h2 id="在-GitHub-上创建仓库"><a href="#在-GitHub-上创建仓库" class="headerlink" title="在 GitHub 上创建仓库"></a>在 GitHub 上创建仓库</h2><p>以上我们是在自己电脑上操作的，外部无法访问到我们的博客，因此，可以将页面代码部署到 GitHub 仓库上，由 GitHub 帮我们解析页面供外部访问。部署的时候，需要有密钥，一般是用 SSH，保证只有自己能上传代码到自己的仓库上。部署完成之后，基本上就搞定了。</p><p><img src="http://p9ucdlghd.bkt.clouddn.com/yanglbme_github.jpg" alt="yanglbme.github.io"></p><h2 id="添加-Gitment"><a href="#添加-Gitment" class="headerlink" title="添加 Gitment"></a>添加 Gitment</h2><p><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment</a> 是一款基于 GitHub Issues 的评论系统，可以为我们的博客添加评论功能，完全不需要后台服务器，用户的每一条评论会存储到 GitHub 的 <a href="https://github.com/yanglbme/yanglbme.github.io/issues/2" target="_blank" rel="noopener">Issues</a> 上，你可以像我一样，将评论添加在自己的博客仓库中，也可以新创建一个仓库专门用于存储评论。</p><p><img src="http://p9ucdlghd.bkt.clouddn.com/issue.jpg" alt="issue"></p><p>评论时需要用户登录 GitHub 账号，没有 GitHub 账号的用户是评论不了的，这与 Gitment 基于 GitHub Issues 有关。</p><p><img src="http://p9ucdlghd.bkt.clouddn.com/gitment.jpg" alt="gitment"></p><p>似乎就这么多了，详细的搭建过程以及如何开始文章的创作，查看网上教程就好了，我就不把链接贴出来了~</p>]]></content>
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>再见，德国</title>
      <link href="/2018/06/28/Goodbye-Germany/"/>
      <url>/2018/06/28/Goodbye-Germany/</url>
      <content type="html"><![CDATA[<p>生活无比残酷，幸运女神不会永远眷顾着你，还是要坚强面对生活。</p><p>再见，日耳曼战车。</p><a id="more"></a><p><img src="http://p9ucdlghd.bkt.clouddn.com/1.png" alt="1"></p><p><img src="http://p9ucdlghd.bkt.clouddn.com/2.png" alt="2"></p><p><img src="http://p9ucdlghd.bkt.clouddn.com/3.png" alt="3"></p><p><img src="http://p9ucdlghd.bkt.clouddn.com/4.png" alt="4"></p>]]></content>
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Just Do IT</title>
      <link href="/2018/06/27/Just-Do-IT/"/>
      <url>/2018/06/27/Just-Do-IT/</url>
      <content type="html"><![CDATA[<h2 id="复习计划"><a href="#复习计划" class="headerlink" title="复习计划"></a>复习计划</h2><ul><li>JVM</li><li>Java Web</li><li>Spring</li><li>MyBatis</li><li>设计模式</li></ul><a id="more"></a><ul><li>操作系统</li><li>数据库</li><li>计算机网络</li><li>数据结构与算法</li><li>Java 基础</li><li>Java 并发</li><li>Java 容器</li><li>Java IO</li></ul>]]></content>
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
